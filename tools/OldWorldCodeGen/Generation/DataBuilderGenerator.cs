using System.Text;
using OldWorldCodeGen.Parsing;

namespace OldWorldCodeGen.Generation;

/// <summary>
/// Generates DataBuilders.Generated.cs from parsed entity getter methods.
/// </summary>
public class DataBuilderGenerator
{
    private readonly TypeAnalyzer _typeAnalyzer;

    public DataBuilderGenerator(TypeAnalyzer typeAnalyzer)
    {
        _typeAnalyzer = typeAnalyzer;
    }

    public string Generate(Dictionary<string, List<GetterSignature>> entityGetters)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine($"// Generated by OldWorldCodeGen at {DateTime.UtcNow:O}");
        sb.AppendLine("// Do not edit manually - regenerate with: dotnet run --project tools/OldWorldCodeGen");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using TenCrowns.GameCore;");
        sb.AppendLine();
        sb.AppendLine("namespace OldWorldAPIEndpoint");
        sb.AppendLine("{");
        sb.AppendLine("    public static partial class DataBuilders");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Safely add a property to the data dictionary, catching any exceptions.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        private static void TryAdd(Dictionary<string, object> data, string key, Func<object> getValue)");
        sb.AppendLine("        {");
        sb.AppendLine("            try { data[key] = getValue(); }");
        sb.AppendLine("            catch { /* Skip properties that throw */ }");
        sb.AppendLine("        }");
        sb.AppendLine();

        foreach (var (entityName, getters) in entityGetters.OrderBy(kv => kv.Key))
        {
            GenerateEntityBuilder(sb, entityName, getters);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private void GenerateEntityBuilder(StringBuilder sb, string entityName, List<GetterSignature> getters)
    {
        // Filter to simple getters (no parameters) for the basic builder
        var simpleGetters = getters
            .Where(g => !g.HasParameters)
            .Where(g => IsSupportedReturnType(g.ReturnType))
            .OrderBy(g => g.PropertyName)
            .ToList();

        sb.AppendLine($"        #region {entityName} Builder");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>");
        sb.AppendLine($"        /// Build a {entityName} object for JSON serialization.");
        sb.AppendLine($"        /// Auto-generated from {entityName}.cs - {simpleGetters.Count} properties.");
        sb.AppendLine($"        /// Each property access is wrapped in try-catch for null safety.");
        sb.AppendLine($"        /// </summary>");
        sb.AppendLine($"        public static object Build{entityName}ObjectGenerated({entityName} entity, Game game, Infos infos)");
        sb.AppendLine("        {");
        sb.AppendLine("            var data = new Dictionary<string, object>();");
        sb.AppendLine();

        foreach (var getter in simpleGetters)
        {
            var accessor = GenerateGetterAccessor(getter, entityName);
            sb.AppendLine($"            TryAdd(data, \"{getter.PropertyName}\", () => {accessor});");
        }

        sb.AppendLine();
        sb.AppendLine("            return data;");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Generate list of getters with parameters (for reference)
        var parameterizedGetters = getters
            .Where(g => g.HasParameters)
            .OrderBy(g => g.Name)
            .ToList();

        if (parameterizedGetters.Any())
        {
            sb.AppendLine($"        // Parameterized getters not included in basic builder:");
            foreach (var getter in parameterizedGetters.Take(20)) // Limit output
            {
                sb.AppendLine($"        // - {getter.Name}({getter.ParameterCount} params) -> {getter.ReturnType}");
            }
            if (parameterizedGetters.Count > 20)
            {
                sb.AppendLine($"        // ... and {parameterizedGetters.Count - 20} more");
            }
            sb.AppendLine();
        }

        sb.AppendLine($"        #endregion");
        sb.AppendLine();
    }

    private string GenerateGetterAccessor(GetterSignature getter, string entityName)
    {
        var entityVar = "entity";

        // Handle enum return types that need mzType resolution
        if (IsEnumType(getter.ReturnType))
        {
            var infosMethod = GetInfosMethodForEnum(getter.ReturnType);
            if (infosMethod != null)
            {
                return $"infos.{infosMethod}({entityVar}.{getter.Name}())?.mzType";
            }
            // Simple enum - just call ToString
            return $"{entityVar}.{getter.Name}().ToString()";
        }

        // Handle nullable types
        if (getter.ReturnType.EndsWith("?"))
        {
            return $"{entityVar}.{getter.Name}()";
        }

        // Simple types
        return $"{entityVar}.{getter.Name}()";
    }

    private bool IsSupportedReturnType(string returnType)
    {
        var baseType = returnType.TrimEnd('?');

        // Primitives
        if (new[] { "int", "Int32", "long", "Int64", "bool", "Boolean", "string", "String",
                    "float", "Single", "double", "Double" }.Contains(baseType, StringComparer.OrdinalIgnoreCase))
        {
            return true;
        }

        // Enums (types ending in Type)
        if (baseType.EndsWith("Type", StringComparison.Ordinal))
        {
            return true;
        }

        // Skip complex types like StringBuilder, IEnumerable, etc.
        if (baseType.Contains("Builder") || baseType.Contains("IEnumerable") ||
            baseType.Contains("List") || baseType.Contains("Dictionary") ||
            baseType.Contains("[]") || baseType.Contains("<"))
        {
            return false;
        }

        // Skip game object types that can't be serialized (have circular references)
        var unsupportedTypes = new[]
        {
            "CitySite", "CityQueueData", "TextVariable", "CharacterStoryData",
            "Tile", "City", "Unit", "Character", "Player", "Family", "Tribe"
        };
        if (unsupportedTypes.Contains(baseType, StringComparer.Ordinal))
        {
            return false;
        }

        // Skip Unity types that have self-referencing properties
        if (baseType.StartsWith("Vector") || baseType.StartsWith("Color") ||
            baseType == "Quaternion" || baseType == "Rect" || baseType == "Bounds")
        {
            return false;
        }

        // Skip void (shouldn't happen for getters)
        if (baseType == "void")
        {
            return false;
        }

        // Allow other simple types
        return true;
    }

    private bool IsEnumType(string returnType)
    {
        var baseType = returnType.TrimEnd('?');
        return baseType.EndsWith("Type", StringComparison.Ordinal);
    }

    private string? GetInfosMethodForEnum(string enumType)
    {
        var baseType = enumType.TrimEnd('?');

        // Map enum types to their infos accessor
        var mappings = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            ["UnitType"] = "unit",
            ["TechType"] = "tech",
            ["ProjectType"] = "project",
            ["YieldType"] = "yield",
            ["ImprovementType"] = "improvement",
            ["ResourceType"] = "resource",
            ["FamilyType"] = "family",
            ["NationType"] = "nation",
            ["TribeType"] = "tribe",
            ["ReligionType"] = "religion",
            ["CultureType"] = "culture",
            ["TerrainType"] = "terrain",
            ["HeightType"] = "height",
            ["VegetationType"] = "vegetation",
            ["PromotionType"] = "promotion",
            ["TraitType"] = "trait",
            ["CouncilType"] = "council",
            ["LawType"] = "law",
            ["SpecialistType"] = "specialist",
            ["JobType"] = "job",
            ["MissionType"] = "mission",
            ["GoalType"] = "goal",
            ["CognomenType"] = "cognomen",
        };

        return mappings.TryGetValue(baseType, out var method) ? method : null;
    }
}

using System.Text;
using OldWorldCodeGen.Parsing;

namespace OldWorldCodeGen.Generation;

/// <summary>
/// Generates CommandExecutor.Generated.cs from parsed method signatures.
/// </summary>
public class CommandExecutorGenerator
{
    private readonly TypeAnalyzer _typeAnalyzer;

    public CommandExecutorGenerator(TypeAnalyzer typeAnalyzer)
    {
        _typeAnalyzer = typeAnalyzer;
    }

    public string Generate(List<MethodSignature> methods)
    {
        // Filter out methods with unsupported parameter types
        var supportedMethods = methods.Where(m => !HasUnsupportedParameters(m)).ToList();
        var skippedMethods = methods.Where(m => HasUnsupportedParameters(m)).ToList();

        // Check for API name collisions within each command
        var collisionErrors = new List<string>();
        foreach (var method in supportedMethods)
        {
            var collisions = TypeAnalyzer.DetectCollisions(method.Parameters.Select(p => p.Name));
            if (collisions.Any())
            {
                foreach (var collision in collisions)
                {
                    collisionErrors.Add($"COLLISION in {method.ActionName}: API name '{collision.Key}' maps to multiple game params: {string.Join(", ", collision.Value)}");
                }
            }
        }

        if (collisionErrors.Any())
        {
            throw new InvalidOperationException(
                "API parameter name collisions detected. Add overrides to resolve:\n" +
                string.Join("\n", collisionErrors));
        }

        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine($"// Generated by OldWorldCodeGen at {DateTime.UtcNow:O}");
        sb.AppendLine("// Do not edit manually - regenerate with: dotnet run --project tools/OldWorldCodeGen");
        sb.AppendLine($"// Supported commands: {supportedMethods.Count}, Skipped: {skippedMethods.Count}");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using TenCrowns.GameCore;");
        sb.AppendLine("using UnityEngine;");
        sb.AppendLine();
        sb.AppendLine("namespace OldWorldAPIEndpoint");
        sb.AppendLine("{");
        sb.AppendLine("    public static partial class CommandExecutor");
        sb.AppendLine("    {");

        // Log skipped methods
        if (skippedMethods.Any())
        {
            sb.AppendLine("        // Methods skipped due to unsupported parameter types:");
            foreach (var m in skippedMethods.OrderBy(m => m.Name))
            {
                var unsupported = m.Parameters.Where(p => p.Kind == ParameterKind.Unknown || p.Kind == ParameterKind.Collection).Select(p => $"{p.Name}:{p.Type}");
                sb.AppendLine($"        // - {m.Name}: {string.Join(", ", unsupported)}");
            }
            sb.AppendLine();
        }

        // MethodInfo fields
        sb.AppendLine("        #region Generated MethodInfo Fields");
        sb.AppendLine();
        sb.AppendLine("        private static Type _clientManagerType;");
        sb.AppendLine();
        foreach (var method in supportedMethods.OrderBy(m => m.Name))
        {
            sb.AppendLine($"        private static MethodInfo _{method.Name}Method;");
        }
        sb.AppendLine();
        sb.AppendLine("        #endregion");
        sb.AppendLine();

        // Reflection initialization
        sb.AppendLine("        #region Generated Reflection Initialization");
        sb.AppendLine();
        sb.AppendLine("        private static void InitializeReflectionGenerated(object clientManager)");
        sb.AppendLine("        {");
        sb.AppendLine("            _clientManagerType = clientManager.GetType();");
        sb.AppendLine();
        foreach (var method in supportedMethods.OrderBy(m => m.Name))
        {
            sb.AppendLine($"            // {method.SignatureComment}");
            sb.AppendLine($"            _{method.Name}Method = _clientManagerType.GetMethod(\"{method.Name}\",");
            sb.AppendLine("                BindingFlags.Public | BindingFlags.Instance);");
            sb.AppendLine();
        }
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        #endregion");
        sb.AppendLine();

        // Type resolvers
        GenerateTypeResolvers(sb);

        // Execute switch
        sb.AppendLine("        #region Generated Execute Switch");
        sb.AppendLine();
        sb.AppendLine("        public static CommandResult ExecuteGenerated(object clientManager, Game game, GameCommand cmd, CommandResult result)");
        sb.AppendLine("        {");
        sb.AppendLine("            string action = cmd.Action?.ToLowerInvariant() ?? \"\";");
        sb.AppendLine();
        sb.AppendLine("            switch (action)");
        sb.AppendLine("            {");
        foreach (var method in supportedMethods.OrderBy(m => m.ActionName))
        {
            sb.AppendLine($"                case \"{method.ActionName.ToLowerInvariant()}\": return Execute{ToPascalCase(method.ActionName)}(clientManager, game, cmd, result);");
        }
        sb.AppendLine("                default:");
        sb.AppendLine("                    result.Error = $\"Unknown action: {cmd.Action}\";");
        sb.AppendLine("                    return result;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        #endregion");
        sb.AppendLine();

        // Execute methods
        sb.AppendLine("        #region Generated Execute Methods");
        sb.AppendLine();
        foreach (var method in supportedMethods.OrderBy(m => m.Name))
        {
            GenerateExecuteMethod(sb, method);
            sb.AppendLine();
        }
        sb.AppendLine("        #endregion");

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private bool HasUnsupportedParameters(MethodSignature method)
    {
        return method.Parameters.Any(p =>
            p.Kind == ParameterKind.Unknown ||
            p.Kind == ParameterKind.Collection ||
            _typeAnalyzer.IsUnsupportedType(p.Type));
    }

    private void GenerateTypeResolvers(StringBuilder sb)
    {
        sb.AppendLine("        #region Generated Type Resolvers");
        sb.AppendLine();

        // Generate resolvers for each enum type that needs Infos lookup
        foreach (var enumInfo in _typeAnalyzer.GetEnumTypesNeedingResolvers().OrderBy(e => e.TypeName))
        {
            sb.AppendLine($"        private static {enumInfo.TypeName} Resolve{enumInfo.TypeName}(Game game, string typeStr)");
            sb.AppendLine("        {");
            sb.AppendLine($"            if (string.IsNullOrEmpty(typeStr) || game == null) return {enumInfo.DefaultValue};");
            sb.AppendLine();
            sb.AppendLine("            Infos infos = game.infos();");
            sb.AppendLine($"            int count = (int)infos.{enumInfo.CountMethod}();");
            sb.AppendLine();
            sb.AppendLine("            for (int i = 0; i < count; i++)");
            sb.AppendLine("            {");
            sb.AppendLine($"                var type = ({enumInfo.TypeName})i;");
            sb.AppendLine($"                var info = infos.{enumInfo.InfosMethod}(type);");
            sb.AppendLine("                if (info != null && info.mzType.Equals(typeStr, StringComparison.OrdinalIgnoreCase))");
            sb.AppendLine("                    return type;");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine($"            return {enumInfo.DefaultValue};");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        // Generate simple enum resolvers (using Enum.TryParse)
        foreach (var enumType in _typeAnalyzer.GetSimpleEnumTypes().OrderBy(e => e))
        {
            var hasNone = _typeAnalyzer.EnumHasNoneValue(enumType);
            var defaultVal = hasNone ? $"{enumType}.NONE" : $"default({enumType})";

            sb.AppendLine($"        private static {enumType} Resolve{enumType}(string typeStr)");
            sb.AppendLine("        {");
            sb.AppendLine($"            if (string.IsNullOrEmpty(typeStr)) return {defaultVal};");
            sb.AppendLine();
            sb.AppendLine($"            if (Enum.TryParse<{enumType}>(typeStr, true, out var result))");
            sb.AppendLine("                return result;");
            sb.AppendLine();
            sb.AppendLine($"            return {defaultVal};");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("        #endregion");
        sb.AppendLine();
    }

    private void GenerateExecuteMethod(StringBuilder sb, MethodSignature method)
    {
        var methodName = ToPascalCase(method.ActionName);

        sb.AppendLine($"        private static CommandResult Execute{methodName}(object clientManager, Game game, GameCommand cmd, CommandResult result)");
        sb.AppendLine("        {");

        // Generate parameter parsing
        var entityParams = new List<(ParameterInfo Param, string VarName)>();
        var enumParams = new List<(ParameterInfo Param, string VarName)>();

        foreach (var param in method.Parameters)
        {
            var varName = param.Name;

            switch (param.Kind)
            {
                case ParameterKind.Entity:
                    // Entity params: parse as int ID, resolve to object later
                    // Use API name for JSON key, game name for C# variable
                    if (param.IsOptional || param.IsNullable)
                    {
                        sb.AppendLine($"            int? {varName}Id = GetIntParamNullable(cmd, \"{param.ApiName}\");");
                    }
                    else
                    {
                        sb.AppendLine($"            if (!TryGetIntParam(cmd, \"{param.ApiName}\", out var {varName}Result))");
                        sb.AppendLine("            {");
                        sb.AppendLine($"                result.Error = GetParamError(\"{param.ApiName}\", {varName}Result, \"integer\");");
                        sb.AppendLine("                return result;");
                        sb.AppendLine("            }");
                    }
                    entityParams.Add((param, varName));
                    break;

                case ParameterKind.EnumType:
                    // Enum params: parse as string, resolve to enum
                    // Use API name for JSON key, game name for C# variable
                    if (param.IsOptional)
                    {
                        var defaultVal = param.DefaultValue ?? $"{param.Type}.NONE";
                        sb.AppendLine($"            string {varName}Str = GetStringParam(cmd, \"{param.ApiName}\", null);");
                        enumParams.Add((param, varName));
                    }
                    else
                    {
                        sb.AppendLine($"            if (!TryGetStringParam(cmd, \"{param.ApiName}\", out var {varName}Result))");
                        sb.AppendLine("            {");
                        sb.AppendLine($"                result.Error = GetParamError(\"{param.ApiName}\", {varName}Result, \"string\");");
                        sb.AppendLine("                return result;");
                        sb.AppendLine("            }");
                        enumParams.Add((param, varName));
                    }
                    break;

                case ParameterKind.Primitive:
                    GeneratePrimitiveParamParsing(sb, param);
                    break;

                default:
                    sb.AppendLine($"            // TODO: Handle parameter {param.Name} of type {param.Type}");
                    break;
            }
        }

        sb.AppendLine();

        // Check method available
        sb.AppendLine($"            if (_{method.Name}Method == null)");
        sb.AppendLine("            {");
        sb.AppendLine($"                result.Error = \"{method.ActionName} command not available\";");
        sb.AppendLine("                return result;");
        sb.AppendLine("            }");
        sb.AppendLine();

        // Try block
        sb.AppendLine("            try");
        sb.AppendLine("            {");

        // Resolve entity IDs to objects
        foreach (var (param, varName) in entityParams)
        {
            var resolverMethod = _typeAnalyzer.GetEntityResolverMethod(param.Type.TrimEnd('?'));
            if (param.IsOptional || param.IsNullable)
            {
                sb.AppendLine($"                {param.Type.TrimEnd('?')} {varName} = {varName}Id.HasValue ? game.{resolverMethod}({varName}Id.Value) : null;");
            }
            else
            {
                sb.AppendLine($"                {param.Type} {varName} = game.{resolverMethod}({varName}Result.Value);");
                sb.AppendLine($"                if ({varName} == null)");
                sb.AppendLine("                {");
                sb.AppendLine($"                    result.Error = $\"{param.Type} not found: {{{varName}Result.Value}}\";");
                sb.AppendLine("                    return result;");
                sb.AppendLine("                }");
            }
        }

        // Resolve enum strings to types
        foreach (var (param, varName) in enumParams)
        {
            var baseType = param.Type.TrimEnd('?');
            var isSimple = _typeAnalyzer.IsSimpleEnumType(baseType);
            var hasNone = _typeAnalyzer.EnumHasNoneValue(baseType);
            var defaultVal = hasNone ? $"{baseType}.NONE" : $"default({baseType})";

            if (param.IsOptional)
            {
                if (isSimple)
                {
                    sb.AppendLine($"                {baseType} {varName} = {varName}Str != null ? Resolve{baseType}({varName}Str) : {defaultVal};");
                }
                else
                {
                    sb.AppendLine($"                {baseType} {varName} = {varName}Str != null ? Resolve{baseType}(game, {varName}Str) : {defaultVal};");
                }
            }
            else
            {
                if (isSimple)
                {
                    sb.AppendLine($"                {param.Type} {varName} = Resolve{param.Type}({varName}Result.Value);");
                }
                else
                {
                    sb.AppendLine($"                {param.Type} {varName} = Resolve{param.Type}(game, {varName}Result.Value);");
                }
                // Only add NONE check if the enum has a NONE value
                if (hasNone)
                {
                    sb.AppendLine($"                if ({varName} == {param.Type}.NONE)");
                    sb.AppendLine("                {");
                    sb.AppendLine($"                    result.Error = $\"Unknown {param.Type}: {{{varName}Result.Value}}\";");
                    sb.AppendLine("                    return result;");
                    sb.AppendLine("                }");
                }
            }
        }

        sb.AppendLine();

        // Invoke method
        var invokeParams = string.Join(", ", method.Parameters.Select(p => p.Name));
        sb.AppendLine($"                _{method.Name}Method.Invoke(clientManager, new object[] {{ {invokeParams} }});");
        sb.AppendLine("                result.Success = true;");

        // Catch block
        sb.AppendLine("            }");
        sb.AppendLine("            catch (Exception ex)");
        sb.AppendLine("            {");
        sb.AppendLine($"                result.Error = $\"{method.ActionName} failed: {{ex.InnerException?.Message ?? ex.Message}}\";");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            return result;");
        sb.AppendLine("        }");
    }

    private void GeneratePrimitiveParamParsing(StringBuilder sb, ParameterInfo param)
    {
        var baseType = param.Type.TrimEnd('?');
        // Use API name for JSON key, game name for C# variable

        if (param.IsOptional || param.IsNullable)
        {
            var defaultVal = param.DefaultValue ?? GetPrimitiveDefault(baseType);
            switch (baseType.ToLowerInvariant())
            {
                case "int":
                case "int32":
                    sb.AppendLine($"            int {param.Name} = GetIntParam(cmd, \"{param.ApiName}\", {defaultVal});");
                    break;
                case "bool":
                case "boolean":
                    sb.AppendLine($"            bool {param.Name} = GetBoolParam(cmd, \"{param.ApiName}\", {defaultVal});");
                    break;
                case "string":
                    sb.AppendLine($"            string {param.Name} = GetStringParam(cmd, \"{param.ApiName}\", {defaultVal ?? "null"});");
                    break;
                default:
                    sb.AppendLine($"            // TODO: Handle optional primitive {param.Name} of type {param.Type}");
                    break;
            }
        }
        else
        {
            switch (baseType.ToLowerInvariant())
            {
                case "int":
                case "int32":
                    sb.AppendLine($"            if (!TryGetIntParam(cmd, \"{param.ApiName}\", out var {param.Name}Result))");
                    sb.AppendLine("            {");
                    sb.AppendLine($"                result.Error = GetParamError(\"{param.ApiName}\", {param.Name}Result, \"integer\");");
                    sb.AppendLine("                return result;");
                    sb.AppendLine("            }");
                    sb.AppendLine($"            int {param.Name} = {param.Name}Result.Value;");
                    break;
                case "bool":
                case "boolean":
                    sb.AppendLine($"            bool {param.Name} = GetBoolParam(cmd, \"{param.ApiName}\", false);");
                    break;
                case "string":
                    sb.AppendLine($"            if (!TryGetStringParam(cmd, \"{param.ApiName}\", out var {param.Name}Result))");
                    sb.AppendLine("            {");
                    sb.AppendLine($"                result.Error = GetParamError(\"{param.ApiName}\", {param.Name}Result, \"string\");");
                    sb.AppendLine("                return result;");
                    sb.AppendLine("            }");
                    sb.AppendLine($"            string {param.Name} = {param.Name}Result.Value;");
                    break;
                default:
                    sb.AppendLine($"            // TODO: Handle primitive {param.Name} of type {param.Type}");
                    break;
            }
        }
    }

    private static string GetPrimitiveDefault(string type)
    {
        return type.ToLowerInvariant() switch
        {
            "int" or "int32" => "-1",
            "bool" or "boolean" => "false",
            "string" => "null",
            _ => "default"
        };
    }

    private static string ToPascalCase(string input)
    {
        if (string.IsNullOrEmpty(input)) return input;
        return char.ToUpperInvariant(input[0]) + input[1..];
    }
}
